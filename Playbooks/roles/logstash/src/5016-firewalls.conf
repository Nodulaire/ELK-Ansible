# TODO See also : http://www.gregmefford.com/blog/2014/09/24/analyzing-cisco-asa-firewall-logs-with-logstash/
input {
        tcp {
                port => 5016
                type => "cisco-asa"
        }
}
filter {
      # Extract fields from the each of the detailed message types
      # The patterns provided below are included in core of LogStash 1.4.2.

  if "ASA-6-302014" in [messsage] or "ASA-6-302016" in [messsage] or "ASA-6-302015" in [messsage] or "ASA-6-302013" in [messsage] {
    grok {
      match => [
          # The following builtin grok don't handle dns name so we modified it to handle hostname and dns name (Do not handle name with underscore)
          # "message", "%{CISCOFW302013_302014_302015_302016}",
          "message", "%{CISCO_ACTION:action}(?: %{CISCO_DIRECTION:direction})? %{WORD:protocol} connection %{INT:connection_id} for %{DATA:src_interface}:%{IPORHOST:src_ip}/%{INT:src_port}( \(%{IPORHOST:src_mapped_ip}/%{INT:src_mapped_port}\))?(\(%{DATA:src_fwuser}\))? to %{DATA:dst_interface}:%{IPORHOST:dst_ip}/%{INT:dst_port}( \(%{IPORHOST:dst_mapped_ip}/%{INT:dst_mapped_port}\))?(\(%{DATA:dst_fwuser}\))?( duration %{TIME:duration} bytes %{INT:bytes})?(?: %{CISCO_REASON:reason})?( \(%{DATA:user}\))?"
        ]
    }
  } else if "ASA-6-302021" in [messsage] or "ASA-6-302020" in [messsage] {
    grok {
      match => [
        # This one is for the hostname and dns name in ASA-6-302021
        # "message", "%{CISCOFW302020_302021}",
        "message", "%{CISCO_ACTION:action}(?: %{CISCO_DIRECTION:direction})? %{WORD:protocol} connection for faddr %{IPORHOST:dst_ip}/%{INT:icmp_seq_num}(?:\(%{DATA:fwuser}\))? gaddr %{IPORHOST:src_xlated_ip}/%{INT:icmp_code_xlated} laddr %{IPORHOST:src_ip}/%{INT:icmp_code}( \(%{DATA:user}\))?"
      ]
    }
  } else if "ASA-4-313005" in [messsage] {
    grok {
      match => [
        # Modification to match dns name
        # "message", "%{CISCOFW313005}",
        "message", "%{CISCO_REASON:reason} for %{WORD:protocol} error message: %{WORD:err_protocol} src %{DATA:err_src_interface}:%{IPORHOST:err_src_ip}(\(%{DATA:err_src_fwuser}\))? dst %{DATA:err_dst_interface}:%{IPORHOST:err_dst_ip}(\(%{DATA:err_dst_fwuser}\))? \(type %{INT:err_icmp_type}, code %{INT:err_icmp_code}\) on %{DATA:interface} interface\.  Original IP payload: %{WORD:protocol} src %{IPORHOST:orig_src_ip}/%{INT:orig_src_port}(\(%{DATA:orig_src_fwuser}\))? dst %{IPORHOST:orig_dst_ip}/%{INT:orig_dst_port}(\(%{DATA:orig_dst_fwuser}\))?"
      ]
    }
  }  else if "ASA-5-304001" in [messsage] {
    grok {
      match => [
      # Special for ASA-5-304001 :
      "message", "(?:%{SYSLOGTIMESTAMP:timestamp}|%{TIMESTAMP_ISO8601:timestamp8601})  %{IPORHOST:srcp_ip} Accessed URL %{IP:dst_ip}:?(%{GREEDYDATA:dst_url})"
      ]
    }
  }  else if "Vpxa" in [messsage] {
      grok {
        match => [
          # ESXI handlers (Vpxa messages):
          "message", "(?:%{SYSLOGTIMESTAMP:timestamp}|%{TIMESTAMP_ISO8601:timestamp8601}) %{IPORHOST:esxi_hostname} %{SYSLOGPROG:esxi_program}(\[%{INT:esxi_pid}\])?: (?<messagebody>(?:\[(?<esxi_thread_id>[0-9A-Z]{8,8}) %{DATA:esxi_loglevel} \'%{DATA:esxi_service}\'(\s.*)?\] %{GREEDYDATA:esxi_message}|%{GREEDYDATA}))"
        ]
      }
    } else {

  grok {
        match => [
                "message", "%{CISCOFW106021}",
                "message", "%{CISCOFW106023}",
                "message", "%{CISCOFW106001}",
                "message", "%{CISCOFW106006_106007_106010}",
                "message", "%{CISCOFW106014}",
                "message", "%{CISCOFW106015}",
                "message", "%{CISCOFW106100}",
                "message", "%{CISCOFW110002}",
                "message", "%{CISCOFW302010}",
                "message", "%{CISCOFW305011}",
                "message", "%{CISCOFW313001_313004_313008}",
                "message", "%{CISCOFW402117}",
                "message", "%{CISCOFW402119}",
                "message", "%{CISCOFW419001}",
                "message", "%{CISCOFW419002}",
                "message", "%{CISCOFW500004}",
                "message", "%{CISCOFW602303_602304}",
                "message", "%{CISCOFW710001_710002_710003_710005_710006}",
                "message", "%{CISCOFW713172}",
                "message", "%{CISCOFW733100}",
                # Rare message handlers
                "message", "%{WORD:action} %{WORD:protocol} %{CISCO_REASON:reason} from %{DATA:src_interface}:%{IP:src_ip}/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}/%{INT:dst_port}; %{GREEDYDATA:dnssec_validation}",
                "message", "%{CISCO_ACTION:action} %{WORD:protocol} %{CISCO_REASON:reason}.*(%{IP:src_ip}).*%{IP:dst_ip} on interface %{GREEDYDATA:interface}",
                "message", "Connection limit exceeded %{INT:inuse_connections}/%{INT:connection_limit} for input packet from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} on interface %{GREEDYDATA:interface}",
                "message", "TCP Intercept %{DATA:threat_detection} to %{IP:ext_nat_ip}/%{INT:ext_nat_port}.*(%{IP:int_nat_ip}/%{INT:int_nat_port}).*Average rate of %{INT:syn_avg_rate} SYNs/sec exceeded the threshold of %{INT:syn_threshold}.#%{INT}",
                "message", "Embryonic connection limit exceeded %{INT:econns}/%{INT:limit} for %{WORD:direction} packet from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} on interface %{GREEDYDATA:interface}"
                ]
        }
    }

  # Parse the syslog severity and facility
  syslog_pri { }
}
output {
  # If your elasticsearch server is discoverable with multicast, use this:
  # elasticsearch { }
  elasticsearch { hosts => "10.6.7.232:9200" }
}
